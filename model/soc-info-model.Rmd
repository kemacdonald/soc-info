---
title: "soc-info model"
output: html_notebook
---


```{r setup, include=FALSE}
library(tidyverse)
library(rwebppl)
library(jsonlite)
library(magrittr)
library(ggthemes)
library(forcats)
library(knitr)
library(gganimate)
library(RColorBrewer)
library(cowplot)
library(here)

```


```{r utils}
utils <- '
var rawProb = function(dist, val) {
  Math.pow(Math.E, dist.score(val))
};
           
var getSymbolEnt = function(prob) {
  prob == 0 ? 0 : prob*Math.log2(prob)* -1
};

var computeEntropy = function(probsVect) {
  var entropyEach = map(function(x) { return getSymbolEnt(x) }, probsVect);  
  var entropyTotal = sum(entropyEach);
  return entropyTotal;
};

var bayesFun = function(A, B, BGivenA) {
  (A * BGivenA) / B
}

var infoGainAnswer = function(priorEnt, condProbs) {
  var posteriorEnt = computeEntropy(condProbs);
  return priorEnt - posteriorEnt;
}

var infoGainQuestion = function(infoGainAnswerVect, probAnswerVect) {
  var multiply = function(x, y) { return x * y; };
  var posteriorEnt = sum(map2(multiply, infoGainAnswerVect, probAnswerVect));
  return posteriorEnt
}
'
```

```{r define}
define <- '
var obsPres = [1, 0];
//var weightBins = [0.1, 0.3, 0.5, 0.7, 0.9]
var weightBins = [0.9, 0.3, 0.5, 0.7, 0.1]

var machineTypes = ["button", "handle", "both"];

// p(machine)
var machineTypePrior = Categorical({vs: machineTypes,
                                    ps: [.4, .4, .2]});

// p(buttonPress)
var actions = ["button", "handle", "both"];
var actionPrior = Categorical({vs: actions,
                                    ps: [.4, .3, .3]}); 

// p(music | action)
var playMusic = function(action) {
  (action == "button") ? .4:
  (action == "handle") ? .4:
  (action == "both") ? 1:
  0
}

// p(machine identity | action & music)
var testMachine = function(state, action) {
  return (action == "button" ? 
          Categorical({vs: machineTypes, 
                       ps: [1, 0, 0]}) :
          action == "handle" ? 
          Categorical({vs: machineTypes, 
                       ps: [0, 1, 0]}) :
          action == "both" ? 
          Categorical({vs: machineTypes, 
                       ps: [0.4, 0.4, 0.2]}) :
          "nothing");
}

// compute info gain for question involving a particular button press (A, B, or A&B)
var igQuestion = function(action) {
  var priorEntLearner = computeEntropy(
    map (function (x) { return Math.pow(Math.E, machineTypePrior.score(x))}, 
         machineTypes));

  var igAnswerYes = infoGainAnswer(priorEntLearner, 
                                    map(function(x) 
                                        {return rawProb(testMachine("state", action),x)}, 
                                        machineTypes))
  var igAnswerNo = infoGainAnswer(priorEntLearner, 
                                    map(function(x) {return 1-rawProb(testMachine("state", action),x)}, 
                                        machineTypes))

  return infoGainQuestion(
                 [igAnswerYes, igAnswerNo],
                 [playMusic(action), 
                  1-playMusic(action)])
}

var optimality = 1.7;
'
```



```{r soc-info}
socInfo <-'
var observer1 = cache(function(action) {
   return Infer({method: "enumerate"}, 
function() {
     var competence = playMusic(action);
     return competence;
  }); 
}, 10000)

var learner1 = cache(function(phi, beta_pres, observerPresent) {
   return Infer({method: "enumerate"}, function() {
     var action = sample(actionPrior);
     var competence = uniformDraw([0,1]);
var O1 = observer1(action);

    var learningUtility = phi*igQuestion(action)
    var presentationUtility = observerPresent*beta_pres*rawProb(O1,competence)
   var performanceUtility = (1-phi)*playMusic(action)

    var learnerUtility = learningUtility + presentationUtility + performanceUtility;

    factor(optimality*learnerUtility)
    return action;  
   
  });   
}, 10000)



//learner1(0.5, 0.6, 1)
'
```

```{r}
learnerCall <- '
_.flattenDeep(
map(function(phi){
map(function(beta_pres){
    map(function(observerPresent){
      var actionProbs = learner1(phi, beta_pres, observerPresent)
      var actObj = _.fromPairs(map(function(a){
        [a, Math.exp(actionProbs.score(a))]
      }, actions))
       return extend(actObj,{ phi: phi, beta_pres: beta_pres, obsPres: observerPresent})
    }, obsPres)
}, weightBins)
}, weightBins))
'
```

### learner viz

```{r}
rs.l1 <- webppl(paste(utils, define, socInfo, learnerCall,  sep = '\n'))


rs.l1.tidy <- data.frame(rs.l1) %>% 
  gather(key=action, value=prob, -phi, -obsPres, -beta_pres)
```

```{r}
fig.l1 <- ggplot(rs.l1.tidy %>%
                   filter(beta_pres == "0.7") %>%
                   mutate(action = relevel(factor(action), ref="both")),
       aes( x = action, y = prob, group = action, fill = action) )+
  geom_bar(position = position_dodge(), stat = 'identity', color = 'black')+
  scale_y_continuous(limits = c(0, 0.9), breaks = c(0, 0.25, 0.5, 0.75))+
  facet_grid(obsPres~phi, labeller=label_both)+
  # scale_fill_manual(values =  rev(brewer.pal(5,"RdBu")))+
  # scale_fill_manual(values =  brewer.pal(4,"RdBu"))+
  scale_fill_solarized()+
  guides(fill = F)+
  theme_few()+
  ylab("action probability")

fig.l1
# ggsave("img/l0.pdf", width = 7, height = 4)
```
